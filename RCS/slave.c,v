head	1.9;
access
	jo;
symbols;
locks
	syl:1.9; strict;
comment	@ * @;


1.9
date	96.06.25.00.39.27;	author jo;	state Exp;
branches;
next	1.8;

1.8
date	96.06.24.23.29.59;	author syl;	state Exp;
branches;
next	1.7;

1.7
date	96.06.24.21.23.33;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	96.06.24.21.22.13;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	96.06.24.19.12.34;	author jo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.24.13.20.03;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	96.06.24.00.13.55;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	96.06.21.16.38.53;	author jo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.21.15.45.43;	author syl;	state Exp;
branches;
next	;


desc
@Esclave du calcul distribue.
@


1.9
log
@Premiere version ou le maitre est bien serveur.
@
text
@		/**********************************************
		 * Esclave du calcul du probleme des N reines *
		 **********************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <fcntl.h>

#include "algo.h"
#include "rezo.h"

char *maitre="holiday";

int fd;
struct sockaddr_in saddr;
struct sockaddr_in myaddr;

int main ()
{
  int un=1;
  unsigned short rgpt = htons(RG);
  unsigned int buf[10];
  struct hostent *hp;

  memset (&saddr, 0, sizeof (struct sockaddr_in));
  memset (&myaddr, 0, sizeof (struct sockaddr_in));

  if ((hp = gethostbyname (maitre)) == NULL) {
    saddr.sin_addr.s_addr = inet_addr (maitre);
    if (saddr.sin_addr.s_addr == -1) {
      fprintf (stderr, "Unknown host: %s\n", maitre);
      exit(1);
    };
  }
  else
    saddr.sin_addr = *(struct in_addr *) (hp->h_addr_list[0]);

  saddr.sin_port = htons(PORT);
  saddr.sin_family = AF_INET;

  myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  myaddr.sin_port = 0;
  myaddr.sin_family = AF_INET;

  if ((fd = socket (PF_INET, SOCK_STREAM, 0)) < 0) {
    perror ("socket");
    exit(1);
  };

  if (setsockopt (fd,SOL_SOCKET,SO_KEEPALIVE,&un,sizeof(int)) < 0) {
    perror ("setsockopt");
    exit(1);
  };

  if (connect(fd, (struct sockaddr *) &saddr, sizeof (saddr)))
  {
    perror ("Connection...");
    exit(1);
  }


  write (fd, &rgpt, sizeof (unsigned short int));

  for (;;)
  {
     read (fd, buf, 3*sizeof (unsigned int));
     nb = 0;
     pipo_str (ntohl (buf[0]), ntohl (buf[1]), ntohl (buf[2]));
     nb = htonl (nb);
     write (fd, &nb, sizeof (unsigned int));
  };
}
@


1.8
log
@Chepu, moi !
@
text
@d13 1
d19 2
d23 1
a26 1
  int ns;
d30 1
a30 2
  struct sockaddr_in lui;
  int l = sizeof (lui);
d33 13
a45 1
  saddr.sin_port = htons (PORT);
d47 4
a50 1
  saddr.sin_addr.s_addr = INADDR_ANY;
d54 1
a54 1
    exit (1);
d57 3
a59 8
     if (setsockopt (fd,SOL_SOCKET,SO_REUSEADDR,&un,sizeof(int))< 0) {
       perror ("setsockopt");
       exit(1);
     };

  if (bind (fd, (struct sockaddr *) &saddr, sizeof (saddr)) < 0) {
    perror ("bind");
    exit (1);
d62 6
a67 4
  if (listen (fd, 5) < 0) {
    perror ("listen");
    exit (1);
  };
d69 1
a69 4
  printf ("Attente de connections, port %d\n", PORT);
  ns = accept (fd, (struct sockaddr *) &lui, &l);
  printf ("Connection !!!\n");
  write (ns, &rgpt, sizeof (unsigned short int));
d73 1
a73 1
     read (ns, buf, 3*sizeof (unsigned int));
d77 1
a77 1
     write (ns, &nb, sizeof (unsigned int));
@


1.7
log
@bon.
@
text
@d40 1
a40 1
     if (setsockopt (fd,SOL_SOCKET,SO_REUSEADDR,&un,1) < 0) {
@


1.6
log
@Ajout du SO_REUSEADDR.
@
text
@d40 1
a40 1
     if (setsockopt (fd[i],SOL_SOCKET,SO_REUSEADDR,&un,1) < 0) {
d42 1
a42 1
         continue;
@


1.5
log
@petit bug
@
text
@d24 1
d39 5
@


1.4
log
@Bug fix pour alpha, sur le rezo (transferts de long).
@
text
@d56 1
a56 1
     read (ns, buf, 4*sizeof (unsigned int));
@


1.3
log
@que dalle.
@
text
@d7 1
d21 1
a21 1
main()
d24 2
a25 2
  unsigned long buf[10];
  struct hostent *luient;
d52 2
a53 2
  buf[0] = htonl(RG);
  write (ns, buf, sizeof (long));
d56 1
a56 1
     read (ns, buf, 4*sizeof (long));
d60 1
a60 1
     write (ns, &nb, sizeof (long));
@


1.2
log
@Verification de RG.
@
text
@d51 2
a52 2
  buf[0]=htonl(RG);
  write(ns,buf,sizeof(long));
@


1.1
log
@Initial revision
@
text
@d51 2
@
