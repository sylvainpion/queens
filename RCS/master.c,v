head	1.13;
access
	jo;
symbols;
locks
	syl:1.13; strict;
comment	@ * @;


1.13
date	96.06.25.16.56.00;	author jo;	state Exp;
branches;
next	1.12;

1.12
date	96.06.25.00.52.18;	author jo;	state Exp;
branches;
next	1.11;

1.11
date	96.06.25.00.39.05;	author jo;	state Exp;
branches;
next	1.10;

1.10
date	96.06.24.23.30.13;	author syl;	state Exp;
branches;
next	1.9;

1.9
date	96.06.24.19.44.46;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	96.06.24.19.12.45;	author jo;	state Exp;
branches;
next	1.7;

1.7
date	96.06.24.17.44.35;	author jo;	state Exp;
branches;
next	1.6;

1.6
date	96.06.24.17.36.24;	author jo;	state Exp;
branches;
next	1.5;

1.5
date	96.06.24.13.20.46;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	96.06.24.00.13.18;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	96.06.23.20.26.13;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	96.06.21.16.39.09;	author jo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.21.15.45.43;	author syl;	state Exp;
branches;
next	;


desc
@MAITRE du calcul distribue.
@


1.13
log
@Une gestion plus propre des logs. Avec DBG_LVL
@
text
@		/*********************************************
		 * Maitre du calcul du probleme des N reines *
		 *********************************************/

/* $Id: master.c,v 1.12 1996/06/25 00:52:18 jo Exp jo $ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <signal.h>

#include "algo.h"    /* juste pour RG et RG_FULL */
#include "rezo.h"

#define DBG_LVL 3
/* 0 -> rien, 1-> arrivee,depart de machines, 2-> fin/reveils
3->avancement du calcul */


#ifndef MACHINES
  #define MACHINES 150
#endif

#ifndef RG_MASTER
  #define RG_MASTER (RG/5)
#endif

/* nb max de machines */
#ifndef MACHINES
  #define MACHINES 100
#endif

#define MODULO 16777216


/* Pour les decomptes */
static unsigned int nb0 = 0;
static unsigned int nb1 = 0;
static unsigned int nb2 = 0;

/* gestion des machines et des calculs a faire... */
static int niveau = 1;
static int etat[50][4];
static int nombre_machines=0;
static unsigned int calcul_en_cours[MACHINES][3];
static unsigned int calcul_a_refaire[MACHINES*10][3];
static int calcul_bidon[3];
static int to_redo = 0;

static int fini = 0;
static int fini_count = 0;

/* les info sur les machines */
int fd[MACHINES];
int soc_princ;
int ok[MACHINES];
int fini_machine[MACHINES];
char machines[MACHINES][100];

/* tentative de gestion des pb des clients... */
static void handle_pipe(int nosig)
{
#if DBG_LVL > 0
  fprintf(stderr," Un pb de socket ... :-((( \n");
  fprintf(stderr, " J'ignore le signal... \n");
#endif
  signal(SIGPIPE,handle_pipe);
}

void accept_connection();

int pipo_next ()
{
/* on utilise etat pour sauvegarder completement les variables locales */
/* pour pouvoir ne plus etre recursif.... */
   unsigned int h = etat[niveau][0];
   unsigned int m = etat[niveau][1];
   unsigned int d = etat[niveau][2];
   unsigned int i = etat[niveau][3];
   unsigned int tot = (h|m|d) ^ RG_FULL;

   if (niveau == 1)
     tot = (RG_FULL >> (RG/2));


   if ((niveau == 2) && ((RG&1) == 1) && (etat[2][0] == (1 << (RG/2))) )
     tot &= (RG_FULL >> (RG/2));

   for (; i <= tot; i <<= 1)
     if ( (tot&i) != 0 )
     {
       etat[niveau][3] = i << 1;
       niveau ++;
       etat[niveau][0] = h|i;
       etat[niveau][1] = ((m|i)<<1)&RG_FULL;
       etat[niveau][2] = (d|i)>>1;
       etat[niveau][3] = 1;
       if (niveau > RG_MASTER) {
         return 1;
       }
       else  return pipo_next ();
     };

    niveau --;
    if (niveau == 0) return -1; /* fin */
    return 0;
}

/* appelee quand une connection bugue */
void mort_client(int ma)
{
     int i;
#if DBG_LVL > 0
     perror("Ecriture :");
#endif
     ok[ma]=0;
     nombre_machines --;
     close(fd[ma]);
     /* pour faire recommencer le meme... */
#if DBG_LVL >0
     printf ("%s nous a quittee..., il reste %d machines.\n",machines[ma],
       nombre_machines);
#endif
     /* on stoque le message a renvoyer a une machine saine... */
     memcpy(calcul_a_refaire[to_redo],calcul_en_cours[ma],3*sizeof(int));
     to_redo++;
     for (i=0;i<MACHINES;i++)
     {
        if (fini_machine[i]&& ok[i])
        {
            /* on veut reveiller des machines pour finir le calcul... */
            fini_count--;
            fini_machine[i]=0;
#if DBG_LVL > 0
            fprintf(stderr,"Je reveille %s...\n",machines[i]);
#endif
#if DBG_LVL > 1
            printf("Je reveille %s...\n",machines[i]);
#endif
            memcpy(calcul_en_cours[i],calcul_bidon,3*sizeof(int));
            if(write(fd[i],calcul_en_cours[i],
              3*sizeof(int)) !=3*sizeof(int))
            {
#if DBG_LVL > 0
               fprintf(stderr,"Ca va mal\n");
#endif
               mort_client(i); /* la on deprime un peu... */
            }
        }
     }
}


void grand_pipo (int ma)
{
  int res;
  int i;

  /* regarde s'il reste des calculs a donner,
   * et compte les machines qui ont fini      */

  if (fini)
  {
    fini_count++;
    fini_machine[ma]=1;
#if DBG_LVL > 1
    printf ("             %s a termine.\n", machines[ma]);
#endif
    return;
  };

  /* attend de trouver qqchose d'interessant
   * ie la fin des calculs, ou un calcul a faire */

  while ((res = pipo_next ())==0);
  if (res == -1)
  {fini_machine[ma]=1;fini = 1;fini_count=1;
#if DBG_LVL > 1
    printf ("             %s a termine.\n", machines[ma]);
#endif
    return;
  }

  /* on convertit avant d'envoyer sur le rezo */

  for (i=0; i < 3; i++)
    calcul_en_cours[ma][i] = htonl (etat[niveau][i]);
  res = write (fd[ma], calcul_en_cours[ma], 3 * sizeof (unsigned int));
  if (res != 3* sizeof(unsigned int))
  {
     /* pour faire recommencer le meme... */
     mort_client(ma);
  }
#if DBG_LVL > 2
  printf ("(%2d) %d %d %d %d %d %d %d\n", ma, etat[1][3], etat[2][3], 
          etat[3][3], etat[4][3], etat[5][3], etat[6][3], etat[7][3]);
#endif

  /* ce niveau a ete fait par le client.
   * Il faut donc redescendre */

  niveau --;
}

void itere_pipo ()
{
   int i;
   fd_set rd;

   etat[1][0] = etat[1][1] = etat[1][2] = 0;
   etat[1][3] = 1;

   /* Lance un premier calcul sur chaque machine */

   for (i=0; i < MACHINES; i++)
      if(ok[i])
         grand_pipo (i);

   /* relance des calculs quand il y en a besoin */

   while ((fini_count < nombre_machines)||(fini==0))
   {
      FD_ZERO (&rd);
      for(i=0; i < MACHINES; i++)
        if(ok[i])
	  FD_SET (fd[i], &rd);
      FD_SET (soc_princ, &rd);

      /* on attend qu'un des esclaves dise qqchose... */

      select (256, &rd, 0, 0, 0);
      if(FD_ISSET(soc_princ,&rd))
         accept_connection();
      for (i=0; i < MACHINES; i++)
         if ((FD_ISSET (fd[i], &rd))&& (ok[i]))
         {
	    if(read (fd[i], &nb0, sizeof (unsigned int))==
	         sizeof(unsigned int))
	    {
	       nb1 += ntohl (nb0);
	       nb2 += nb1 / MODULO;
	       nb1 = nb1 % MODULO;
	       if (to_redo >0)
	       {
#if DBG_LVL > 1
                  printf("Je relance un calcul... \n");
#endif
	          memcpy(calcul_en_cours[i],calcul_a_refaire[--to_redo],
		    3 * sizeof(unsigned int));
		  if(write(fd[i],calcul_en_cours[i],
		     3*sizeof(unsigned int)) != 3 * sizeof(unsigned int))
		  {
		     mort_client(i);
		  }
	       } else
		  grand_pipo (i);
            }
	    else
	    {
	       mort_client(i);
	    }
	 };
   };
}

void init()
{
  signal(SIGPIPE,handle_pipe);
  calcul_bidon[0]=calcul_bidon[1]=calcul_bidon[2]=htonl(RG_FULL);
}

void accept_connection()
{
  int i;
  int un=1;
  int numero=0;
  static struct sockaddr_in lui;
  static struct hostent *luient;
  static int l=sizeof (lui);

  for(i=0;i<MACHINES;i++)
  {
    if (!ok[i]) {numero=i; break; }
  }
  if (ok[numero])
  {
    fprintf(stderr,"J'ai atteint le nombre maximum de clients... (%d) \n",
       MACHINES);
    close(accept(soc_princ, (struct sockaddr *) &lui, &l));
    return;
  }
  fd[numero]= accept(soc_princ, (struct sockaddr *) &lui, &l);
  if (setsockopt (fd[numero],SOL_SOCKET,SO_KEEPALIVE,&un,sizeof(int)) < 0) {
       perror ("setsockopt");
       return;
  };
  luient = gethostbyaddr ((char *) & (lui.sin_addr.s_addr),
          sizeof(lui.sin_addr.s_addr),AF_INET);
	     
  if(!luient)
  {
     fprintf(stderr,"Je ne sais pas qui se connecte...\n");
     strncpy(machines[numero],"???",sizeof(machines[numero]));
  } else
  {
#if DBG_LVL > 0
     printf("Connexion de %s\n",luient->h_name);
#endif
     strncpy(machines[numero],luient->h_name,sizeof(machines[numero]));
  }
  {
       unsigned short int sonrg;
       read (fd[numero], &sonrg, sizeof(unsigned short int));
       if (ntohs(sonrg) != RG)
       {
         fprintf(stderr," Le client sur %s a un RG de %d et moi de %d\n",
	         machines[numero], ntohs (sonrg), RG);
#if DBG_LVL > 0
         printf(" Refusee... Mauvais RG\n");
#endif
         close(fd[numero]);
         return;
       }
  };

  ok[numero]=1;
  fini_machine[numero]=0;
  nombre_machines++;
  /* on la fait demarrer... */
  write(fd[numero],calcul_bidon,3*sizeof(int));
}

void init_rezo()
{
  int un=1;
  struct sockaddr_in myaddr;

  memset (&myaddr, 0, sizeof (struct sockaddr_in));
  
  myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  myaddr.sin_port = htons(PORT);
  myaddr.sin_family = AF_INET;

  if ((soc_princ = socket (PF_INET, SOCK_STREAM, 0)) < 0) {
      perror ("socket");
      exit(1);
  };
  

  if (setsockopt (soc_princ,SOL_SOCKET,SO_REUSEADDR,&un,sizeof(int))< 0) {
       perror ("setsockopt");
       exit(1);
  };

  if (bind (soc_princ, (struct sockaddr *) &myaddr, sizeof (myaddr)) < 0) {
    perror ("bind");
    exit (1);
  };

  if (listen (soc_princ, 5) < 0) {
    perror ("listen");
    exit (1);
  };
  printf("Attente de connections port :%d\n",PORT);
}

int main ()
{
  init();
  init_rezo();
  itere_pipo ();
  printf ("%d reines -> 2 * (%d + (%d * %d )) sols\n",
          RG, nb1, nb2, MODULO);
  return 0;
}
@


1.12
log
@Typos. MODULO
@
text
@d5 1
a5 1
/* $Id: master.c,v 1.11 1996/06/25 00:39:05 jo Exp jo $ */
d23 5
d29 1
a29 1
  #define MACHINES 100
d71 1
d74 1
d121 1
d123 1
d128 1
d131 1
d142 1
d144 4
d152 3
a154 1
               printf("Ca va mal\n");
d174 3
a176 1
    printf ("             %d a termine.\n", ma);
d186 3
a188 1
    printf ("             %d a termine.\n", ma);
d202 4
a205 2
  printf ("(%2d) %d %d %d %d %d %d %d\n", ma, etat[0][3], etat[1][3], 
          etat[2][3], etat[3][3], etat[4][3], etat[5][3], etat[6][3]);
d253 1
d255 1
d314 1
d316 1
d326 3
@


1.11
log
@Premiere version ou le maitre est bien serveur.
@
text
@d5 1
a5 1
/* $Id: master.c,v 1.10 1996/06/24 23:30:13 syl Exp jo $ */
d24 1
a24 1
  #define MACHINES 1
d36 2
a37 1
#define MODULO 65536
d271 1
@


1.10
log
@X'est penible a mettre, ce baratin !
@
text
@d5 1
a5 1
/* $Id: master.c,v 1.9 1996/06/24 19:44:46 syl Exp syl $ */
a21 1
#include "machines.h"
d31 5
d38 1
d43 1
d48 1
a48 1
static unsigned int *calcul_a_refaire[MACHINES];
d55 1
d57 1
d60 1
a60 3
struct sockaddr_in saddr;
struct sockaddr_in myaddr;
struct hostent *hp;
d62 1
a62 1
/* tentative de gestion des pb des fils... */
d70 1
d109 1
d120 2
a121 1
     calcul_a_refaire[to_redo]=calcul_en_cours[ma];
d127 1
d204 1
a204 7
   if(nombre_machines==0)
   {
      fprintf(stderr,"Faut pas se foutre du monde... Je suis le MAITRE,\n");
      fprintf(stderr,"je ne vais quand meme pas bosser...\n");
      exit(-1);
   }
   while (fini_count < nombre_machines)
d210 1
d215 2
a244 4
   if(nombre_machines==0)
   { fprintf(stderr, "Y'a plus personne pour bosser\n");
      exit(1);
   }
d247 7
a253 1
int main ()
d257 4
d262 5
a266 7
  signal(SIGPIPE,handle_pipe);

  calcul_bidon[0]=calcul_bidon[1]=calcul_bidon[2]=htonl(RG_FULL);
  memset (&saddr, 0, sizeof (struct sockaddr_in));
  memset (&myaddr, 0, sizeof (struct sockaddr_in));

  for(i=0; i<MACHINES; i++)
d268 6
a273 22
     if ((hp = gethostbyname (machines[i])) == NULL) {
       saddr.sin_addr.s_addr = inet_addr (machines[i]);
       if (saddr.sin_addr.s_addr == -1) {
	 fprintf (stderr, "Unknown host: %s\n", machines[i]);
         continue;
       };
     }
     else
       saddr.sin_addr = *(struct in_addr *) (hp->h_addr_list[0]);

     saddr.sin_port = htons(PORT);
     saddr.sin_family = AF_INET;

     myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
     myaddr.sin_port = 0;
     myaddr.sin_family = AF_INET;

     if ((fd[i] = socket (PF_INET, SOCK_STREAM, 0)) < 0) {
       perror ("socket");
         continue;
     };
     if (setsockopt (fd[i],SOL_SOCKET,SO_KEEPALIVE,&un,sizeof(int)) < 0) {
d275 15
a289 8
         continue;
     };
     if (connect (fd[i], (struct sockaddr *) &saddr, sizeof (saddr))) {
       fprintf(stderr," Connection a : %s\n",machines[i]);
       perror ("connection au serveur...");
         continue;
     };
     {
d291 1
a291 1
       read (fd[i], &sonrg, sizeof(unsigned short int));
d295 3
a297 3
	         machines[i], ntohs (sonrg), RG);
         close(fd[i]);
         continue;
a298 5
     };
     printf("%s est avec nous...\n",machines[i]);
     nombre_machines++;
     fini_machine[i]=0;
     ok[i]=1;
d301 45
@


1.9
log
@version.
@
text
@d5 1
a5 1
/* $Id:$ */
d278 1
a278 1
     if (setsockopt (fd[i],SOL_SOCKET,SO_KEEPALIVE,&un,1) < 0) {
@


1.8
log
@Probleme si le plantage d'un client est a la fin...
Ok.
@
text
@d5 2
@


1.7
log
@Petits bugs mineurs corriges...
@
text
@d39 1
a39 1
static unsigned int calcul_en_cours[MACHINES][4];
d41 1
a41 1
static int calcul_bidon[] = {-1,-1,-1};
d45 1
d106 1
d116 1
a116 1
            fini--;
d120 1
a120 1
            if(write(fd[i],calcul_bidon,
d123 1
d139 1
a139 1
  if (fini>0)
d141 1
a141 1
    fini++;
d152 1
a152 1
  {fini_machine[ma]=0;fini = 1;
d198 1
a198 1
   while (fini < nombre_machines)
d202 2
a203 1
	FD_SET (fd[i], &rd);
d219 1
a219 1
                  printf("Je relance un calcul...\n");
d249 1
d292 1
d298 1
@


1.6
log
@Debut de gestion des plantages des esclaves...
@
text
@d106 1
a106 1
     printf ("%s nous a quittee..., il reste %d machines.",machines[ma],
a202 4
      if(nombre_machines==0)
      { fprintf(stderr, "Y'a plus personne pour bosser\n");
        exit(1);
      }
d232 4
@


1.5
log
@Bug fix pour que ca marche.
@
text
@d16 1
d38 5
d47 2
d53 8
d99 29
a130 1
  unsigned int buf[3];
d139 1
d148 5
a152 1
  if (res == -1) {fini = 1; return;};
d157 7
a163 2
    buf[i] = htonl (etat[niveau][i]);
  write (fd[ma], buf, 3 * sizeof (unsigned int));
d184 2
a185 1
      grand_pipo (i);
d189 7
a195 1
   while (fini < MACHINES)
d203 4
d209 1
a209 1
         if (FD_ISSET (fd[i], &rd))
d211 23
a233 5
	    read (fd[i], &nb0, sizeof (unsigned int));
	    nb1 += ntohl (nb0);
            nb2 += nb1 / MODULO;
	    nb1 = nb1 % MODULO;
	    grand_pipo (i);
d241 4
d254 1
a254 1
	 exit (1);
d269 5
a273 1
       exit (1);
d278 1
a278 1
       exit (-1);
d284 1
d287 2
d290 3
@


1.4
log
@Du formatage a ma mode, et une gestion des debordements commune avec
apart.c
@
text
@d7 1
d31 3
a33 3
static long nb0 = 0;
static long nb1 = 0;
static long nb2 = 0;
d86 1
a86 1
  long buf[3];
d92 6
a97 1
  if (fini>0) { fini++; return;};
d109 1
a109 1
  write (fd[ma], buf, 3 * sizeof (long));
d146 1
a146 4
	    read (fd[i], &nb0, sizeof (long));

            /* on recupere le resultat */

a149 1
/* if ((signed) nb1 < 0) { nb1 <<= 1; nb1 >>= 1; nb2++;}; */
d190 3
a192 3
       long sonrg;
       read(fd[i],&sonrg,sizeof(long));
       if (ntohl(sonrg) != RG)
d194 1
a194 1
	         machines[i], ntohl (sonrg), RG);
d199 1
a199 1
  printf ("%d reines -> 2 * (%d + (%d * 2^%d )) sols\n",
d201 1
@


1.3
log
@Typos.
@
text
@d28 2
a44 7
void mul2 ()
{
   nb1 <<= 1;
   nb2 <<= 1;
   if ((signed) nb1 < 0) { nb1 <<= 1; nb1 >>= 1; nb2++;};
}

d88 3
a90 2
  /* regarde s'il reste des calculs a donner, et compte les machines qui ont
fini */
d93 3
a95 2
  /* attend de trouver qqchose d'interessant */
  /* ie la fin des calculs, ou un calcul a faire */
d100 1
d106 4
a109 1
  /* ce niveau a ete fait par le client. Il faut donc redescendre */
d120 1
d122 1
d127 1
d133 1
d135 1
d141 1
d143 1
d145 3
a147 1
	    if ((signed) nb1 < 0) { nb1 <<= 1; nb1 >>= 1; nb2++;};
d190 4
a193 6
       if(ntohl(sonrg) != RG)
       {
          fprintf(stderr," Le client sur %s a un RG de %d et moi de %d\n",
	          machines[i],ntohl(sonrg),RG);
       }
     }
d196 3
a198 3
   itere_pipo ();
   printf ("%d reines -> %d + (%d * 2^%d ) sols\n",
	   RG, nb1, nb2, 8 * sizeof (long));
@


1.2
log
@Verification de RG. Va avec slave.c v 1.2
@
text
@a113 1
   int res = 1;
d115 1
a115 1
   fd_set rd, wr;
d119 1
a119 1
   /* Lance un premier clacul sur chaque machine */
d123 1
a123 1
   /* relance des claculs quand il y en a besoin */
d129 1
a129 1
      /* on attends qu'un des esclaves dise qqchose... */
d135 1
a135 1
            /* on recupere le sesultat */
d143 1
a143 1
main()
@


1.1
log
@Initial revision
@
text
@d178 9
@
